<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>5</storyId>
    <title>Data Registry Write/Read Stress Test</title>
    <status>drafted</status>
    <generatedAt>2025-11-10</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-5-data-registry-write-read-stress-test.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Beatsy developer</asA>
    <iWant>to validate that HA's in-memory storage (both hass.data and entry.runtime_data patterns) can handle rapid game state updates</iWant>
    <soThat>I avoid performance issues during live gameplay and choose the best 2025 pattern for production</soThat>
    <tasks>
      - Task 1: Create Typed Game State Data Structure (AC: #1, #4) **[2025 PATTERN]**
      - Task 2: Create State Test Module with Dual Pattern Support (AC: #1, #2, #4) **[2025 PATTERN]**
      - Task 3: Add Performance Metrics Tracking (AC: #2, #5) **[2025 PATTERN]**
      - Task 4: Create Test Script for Manual Execution (AC: #1-5) **[2025 PATTERN]**
      - Task 5: Implement Data Integrity Validation (AC: #4)
      - Task 6: Update Component Init to Support Test Mode (AC: #1)
      - Task 7: Monitor HA System Responsiveness (AC: #3)
      - Task 8: Document Storage Strategy (AC: #5) **[2025 PATTERN UPDATE]**
      - Task 9: Run Test and Collect Metrics (AC: #1-5) **[MANUAL TESTING REQUIRED - 2025 PATTERN]**
      - Task 10: Validate Results Against Targets (AC: #2, #5) **[2025 PATTERN]**
    </tasks>
  </story>

  <acceptanceCriteria>
    AC-1: Data Registry Write/Read Operations (2025 Pattern)
      - Given: Beatsy component has access to in-memory storage (via entry.runtime_data or hass.data[DOMAIN])
      - When: test writes game state 100 times in 30 seconds (simulating 10 players, 3 rounds)
      - Then: all writes complete without errors
      - And: subsequent reads return accurate data
      - And: no data corruption occurs
      - And: HA logs confirm completion
      - And: test validates both legacy hass.data and modern entry.runtime_data patterns

    AC-2: Performance Metrics
      - Given: stress test runs for 100 write+read cycles
      - When: performance metrics are calculated
      - Then: average write latency is < 300ms per operation
      - And: maximum latency < 500ms
      - And: total test duration < 30 seconds
      - And: performance metrics are logged

    AC-3: Home Assistant Responsiveness
      - Given: stress test is running
      - When: monitoring HA system state
      - Then: Home Assistant remains responsive (no UI lag)
      - And: HA logs show no performance warnings
      - And: HA resource usage stays acceptable (< 50% CPU spike)
      - And: other HA integrations continue functioning normally

    AC-4: Data Integrity Validation
      - Given: 100 write+read cycles have completed
      - When: validating data integrity
      - Then: all reads return exactly what was written (no data loss)
      - And: player score increments are sequential and correct
      - And: no race conditions or data corruption detected
      - And: data structure remains valid after all operations

    AC-5: Test Documentation
      - Given: all stress tests complete
      - When: developer reviews test results
      - Then: test script outputs performance metrics to JSON file
      - And: metrics include total operations, duration, latencies, errors, storage_pattern_used
      - And: results confirm in-memory storage (both patterns) is suitable
      - And: documentation includes confirmation of storage strategy
      - And: test compares performance between hass.data and entry.runtime_data patterns
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Foundation & Multi-Risk POC</title>
        <section>Story 1.5: Data Registry Write/Read Stress Test</section>
        <snippet>Validates that HA's data registry handles rapid game state updates. Test performs 100 write+read cycles simulating 10 players over 3 rounds, measuring performance metrics. Target: < 300ms avg latency, < 30 seconds total duration, 100% data integrity.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Beatsy Technical Architecture</title>
        <section>ADR-002: Hybrid State Storage (Memory + Registry)</section>
        <snippet>Active game state in memory for fast gameplay, snapshots to HA Registry for crash recovery. In-memory state eliminates I/O latency during gameplay while Registry persistence enables recovery and game history.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Beatsy Technical Architecture</title>
        <section>Technology Stack - Game State Storage</section>
        <snippet>Hybrid approach: fast in-memory gameplay state, persistent config/scores. Uses hass.data for active game operations, HA Registry for configuration and historical data.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Beatsy Product Requirements Document</title>
        <section>NFR-R2: Data Integrity</section>
        <snippet>Zero tolerance for score corruption or data loss. All player scores, guesses, and game state must be accurately maintained throughout gameplay with no race conditions or data integrity issues.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>home-assistant-config/custom_components/beatsy/__init__.py</path>
        <kind>component initialization</kind>
        <symbol>async_setup</symbol>
        <lines>23-136</lines>
        <reason>Shows existing hass.data[DOMAIN] initialization pattern (line 34-35). Story 1.5 will add state_test module import and game_state structure to this existing pattern.</reason>
      </file>
      <file>
        <path>home-assistant-config/custom_components/beatsy/const.py</path>
        <kind>constants</kind>
        <symbol>DOMAIN</symbol>
        <lines>3</lines>
        <reason>DOMAIN constant used throughout for hass.data key. State test will use hass.data[DOMAIN] for test data structure.</reason>
      </file>
      <file>
        <path>tests/poc_spotify_test.py</path>
        <kind>test script</kind>
        <symbol>N/A</symbol>
        <lines>N/A</lines>
        <reason>Example POC test script pattern from Story 1.4. Story 1.5 will follow similar pattern for state test script (CLI args, JSON metrics output).</reason>
      </file>
    </code>
    <dependencies>
      <python>
        <package name="homeassistant.core" version="2024.1+" usage="HomeAssistant instance, hass.data registry access" />
        <package name="logging" version="stdlib" usage="Module-level logger for test output" />
        <package name="time" version="stdlib" usage="High-precision timing with time.perf_counter() for latency measurement" />
        <package name="dataclasses" version="stdlib (3.7+)" usage="PerformanceMetrics dataclass for structured metrics" />
        <package name="asyncio" version="stdlib" usage="Async test execution pattern" />
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use async/await patterns consistent with Home Assistant 2025 standards</constraint>
    <constraint>Use module-level logger: _LOGGER = logging.getLogger(__name__)</constraint>
    <constraint>Test BOTH storage patterns: hass.data[DOMAIN] (legacy) AND entry.runtime_data (2025 best practice)</constraint>
    <constraint>Use dataclasses with full type hints for GameStateData structure (HA 2025 pattern)</constraint>
    <constraint>Use Python 3.11+ type hints throughout: dict[str, Any], list[Player], etc.</constraint>
    <constraint>Use time.perf_counter() for high-precision latency measurement (not time.time())</constraint>
    <constraint>Test script must output metrics to JSON file for POC Decision Document (Story 1.7)</constraint>
    <constraint>Add --pattern CLI arg to test: hass_data, runtime_data, or both</constraint>
    <constraint>Compare performance between both patterns and document findings</constraint>
    <constraint>Follow existing POC test script pattern from Story 1.4 (CLI args, standalone execution)</constraint>
    <constraint>Do NOT use hass.helpers.storage for this test (too slow - Story 1.5 validates in-memory only)</constraint>
    <constraint>Implement read-after-write validation pattern for data integrity verification</constraint>
    <constraint>Log all operations at INFO level for POC visibility</constraint>
    <constraint>Recommend entry.runtime_data for Epic 2+ production (better type safety, automatic cleanup)</constraint>
    <constraint>Reference HA 2025 blog post: https://developers.home-assistant.io/blog/2024/04/30/store-runtime-data-inside-config-entry/</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>hass.data[DOMAIN] (Legacy Pattern)</name>
      <kind>data registry</kind>
      <signature>hass.data[DOMAIN] = {"game_state": {...}, "ws_connections": {...}, "spotify": {...}}</signature>
      <path>home-assistant-config/custom_components/beatsy/__init__.py</path>
      <description>Legacy hass.data pattern. Story 1.5 tests this pattern for backward compatibility and performance comparison.</description>
    </interface>
    <interface>
      <name>entry.runtime_data (2025 Best Practice)</name>
      <kind>config entry runtime data</kind>
      <signature>entry.runtime_data = GameStateData(...) where entry is ConfigEntry[GameStateData]</signature>
      <path>home-assistant-config/custom_components/beatsy/state_test.py (NEW)</path>
      <description>HA 2025 recommended pattern for storing runtime data. Provides type safety, automatic cleanup. Story 1.5 tests this pattern for production readiness.</description>
    </interface>
    <interface>
      <name>GameStateData</name>
      <kind>dataclass</kind>
      <signature>@dataclass class GameStateData: players: list[Player], current_round: Round, played_songs: list[str]</signature>
      <path>home-assistant-config/custom_components/beatsy/state_test.py (NEW)</path>
      <description>Typed game state structure for 2025 pattern. Used with entry.runtime_data for type-safe storage.</description>
    </interface>
    <interface>
      <name>PerformanceMetrics</name>
      <kind>dataclass</kind>
      <signature>@dataclass class PerformanceMetrics: test_type: str, storage_pattern: str, total_operations: int, duration_seconds: float, success_count: int, failure_count: int, avg_latency_ms: float, max_latency_ms: float, errors: list[str]</signature>
      <path>home-assistant-config/custom_components/beatsy/state_test.py (NEW)</path>
      <description>Performance metrics structure with storage_pattern field for comparing hass.data vs entry.runtime_data. Returned by run_state_stress_test() function.</description>
    </interface>
    <interface>
      <name>run_state_stress_test</name>
      <kind>async function</kind>
      <signature>async def run_state_stress_test(hass: HomeAssistant, use_runtime_data: bool = False) -> PerformanceMetrics</signature>
      <path>home-assistant-config/custom_components/beatsy/state_test.py (NEW)</path>
      <description>Main test function that performs 100 write+read cycles. Tests both hass.data (use_runtime_data=False) and entry.runtime_data (use_runtime_data=True) patterns. Returns performance metrics for comparison.</description>
    </interface>
    <interface>
      <name>BeatsyConfigEntry</name>
      <kind>type alias</kind>
      <signature>type BeatsyConfigEntry = ConfigEntry[GameStateData]</signature>
      <path>home-assistant-config/custom_components/beatsy/state_test.py (NEW)</path>
      <description>Typed ConfigEntry alias for HA 2025 pattern. Enables full type checking when accessing entry.runtime_data.</description>
    </interface>
  </interfaces>
  <tests>
    <standards>
      POC validation testing approach with HA 2025 pattern comparison. Manual execution with automated metrics collection. Test scripts follow CLI pattern with JSON metrics output. Use Python stdlib for testing (no pytest for POC). Focus on feasibility validation AND pattern comparison (hass.data vs entry.runtime_data). All tests use real HA instance (no mocking). Performance testing with time.perf_counter() for high-precision measurements. 2025 Update: Test both legacy and modern storage patterns to validate migration path.
    </standards>
    <locations>
      tests/ - POC test scripts (poc_spotify_test.py, poc_websocket_load_test.py exist)
      tests/poc_state_test.py - NEW: State stress test script with dual pattern support
      tests/poc_metrics.json - Metrics output file with pattern comparison for POC Decision Document (Story 1.7)
      home-assistant-config/custom_components/beatsy/state_test.py - NEW: State test module with GameStateData dataclasses
    </locations>
    <ideas>
      AC-1: Test 100 write+read cycles for BOTH patterns (hass.data and entry.runtime_data)
      AC-2: Verify average latency < 300ms and max latency < 500ms for BOTH patterns
      AC-3: Monitor HA responsiveness during test (manual check - UI should not lag)
      AC-4: Validate data integrity - every read must match corresponding write (both patterns)
      AC-5: Output performance metrics with pattern comparison to JSON for Story 1.7

      Test Ideas (2025 Pattern):
      - Create typed GameStateData dataclass with Player, Round, Guess dataclasses
      - Test hass.data pattern: Convert dataclass to dict with asdict(), store in hass.data[DOMAIN]
      - Test entry.runtime_data pattern: Store GameStateData directly in mock ConfigEntry
      - Simulate realistic game state (10 players, 3 rounds worth of data)
      - Measure latency for each write+read cycle individually (both patterns)
      - Track success/failure count for each operation
      - Validate sequential score increments (no corruption or race conditions)
      - Compare performance: hass.data vs entry.runtime_data (expect similar performance)
      - Log all operations at INFO level with pattern indicator
      - Calculate avg/max latency for each pattern separately
      - Output metrics with pattern_comparison field showing differences
      - Recommend entry.runtime_data for production (better type safety, not performance)
    </ideas>
  </tests>
</story-context>
